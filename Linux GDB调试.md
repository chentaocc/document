## Linux GDB调试

> GDB 是一套字符界面的程序集，可以使用命令 gdb 加载要调试的程序。
>
> [https://subingwen.cn/linux/gdb/](https://subingwen.cn/linux/gdb/)

### 调试准备

项目编译时加入如下参数：

- -g：打开调试选项，选项的作用是在可执行文件中加入源代码的信息
- -O0：在尽量不影响程序行为的情况下关掉编译器的优化选项
- -Wall：打开所有 warning

```makefile
# -g 将调试信息写入到可执行程序中
$ gcc -g args.c -o app

# 编译不添加 -g 参数
$ gcc args.c -o app1  

# 查看生成的两个可执行程序的大小
$ ll

-rwxrwxr-x  1 robin robin 9816 Apr 19 09:25 app*	# 可以用于gdb调试
-rwxrwxr-x  1 robin robin 8608 Apr 19 09:25 app1*	# 不能用于gdb调试
```

### 启动和退出gdb

#### 启动gdb

```makefile
# 在终端中执行如下命令
# gdb程序启动了, 但是可执行程序并没有执行
$ gdb 可执行程序的名字

# 使用举例：
$ gdb app
(gdb) 		# gdb等待输入调试的相关命令
```

#### 命令行传参

```makefile
# 设置的时机: 启动gdb之后, 在应用程序启动之前
(gdb) set args 参数1 参数2 .... ...
# 查看设置的命令行参数
(gdb) show args
```

#### gdb中启动程序

在gdb中启动要调试的应用程序有两种方式, 一种是使用run命令, 另一种是使用start命令启动。在整个 gdb 调试过程中, 启动应用程序的命令只能使用一次。

- run: 可以缩写为 r, 如果程序中设置了断点会停在第一个断点的位置, 如果没有设置断点, 程序就执行完了
- start: 启动程序, 最终会阻塞在main函数的第一行，等待输入后续其它 gdb 指令

```shell
# 两种方式
# 方式1: run == r 
(gdb) run  

# 方式2: start
(gdb) start
```

如果想让程序start之后继续运行, 或者在断点处继续运行，可以使用 continue命令, 可以简写为 c

```shell
# continue == c
(gdb) continue
```

#### 退出gdb

退出gdb调试, 就是终止 gdb 进程, 需要使用 quit命令, 可以缩写为 q

```shell
# quit == q
(gdb) quit
```

### 查看代码

查看代码的命令叫做list可以缩写为 l，通过这个命令我们可以查看项目中任意一个文件中的内容，并且还可以通过文件行号，函数名等方式查看。

#### 当前文件

一个项目中一般是有很多源文件的，默认情况下通过list查看到代码信息位于程序入口函数main对应的的那个文件中。因此如果不进行文件切换main函数所在的文件就是当前文件，如果进行了文件切换，切换到哪个文件哪个文件就是当前文件。查看文件内容的方式如下：

```shell
# 使用 list 和使用 l 都可以
# 从第一行开始显示，继续显示输入l或者按enter
(gdb) list 

# 列值这行号对应的上下文代码, 默认情况下只显示10行内容
(gdb) list 行号

# 显示这个函数的上下文内容, 默认显示10行
(gdb) list 函数名
```

#### 切换文件

在查看文件内容的时候，很多情况下需要进行文件切换，我们只需要在list命令后边将要查看的文件名指定出来就可以了，切换命令执行完毕之后，这个文件就变成了当前文件。文件切换方式如下：

```shell
# 切换到指定的文件，并列出这行号对应的上下文代码, 默认情况下只显示10行内容
(gdb) l 文件名:行号

# 切换到指定的文件，并显示这个函数的上下文内容, 默认显示10行
(gdb) l 文件名:函数名
```

#### 设置显示的行数

默认通过list只能一次查看10行代码, 如果想显示更多, 可以通过set listsize设置, 同样如果想查看当前显示的行数可以通过 show listsize查看, 这里的listsize可以简写为 list。具体语法格式如下:

```shell
# 以下两个命令中的 listsize 都可以写成 list
(gdb) set listsize 行数

# 查看当前list一次显示的行数
(gdb) show listsize
```

### 断点操作

#### 设置断点

- 常规断点，程序只要运行到这个位置就会被阻塞

  - 设置普通断点到当前文件

  ```shell
  # 在当前文件的某一行上设置断点
  # break == b
  (gdb) b 行号
  (gdb) b 函数名		# 停止在函数的第一行
  ```

  - 设置普通断点到某个非当前文件上

  ```shell
  # 在非当前文件的某一行上设置断点
  (gdb) b 文件名:行号
  (gdb) b 文件名:函数名		# 停止在函数的第一行
  ```

- 条件断点，只有指定的条件被满足了程序才会在断点处阻塞。

  ```shell
  # 必须要满足某个条件, 程序才会停在这个断点的位置上
  # 通常情况下, 在循环中条件断点用的比较多	
  (gdb) b 行数 if 变量名==某个值
  ```

#### 查看断点

断点设置完毕之后, 可以通过 info break命令查看设置的断点信息，其中info可以缩写为i

```shell
# info == i
# 查看设置的断点信息
(gdb) i b   #info break

# 举例
(gdb) i b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000400cb5 in main() at test.cpp:12
2       breakpoint     keep y   0x0000000000400cbd in main() at test.cpp:13
3       breakpoint     keep y   0x0000000000400cec in main() at test.cpp:18
4       breakpoint     keep y   0x00000000004009a5 in insertionSort(int*, int) 
                                                   at insert.cpp:8
5       breakpoint     keep y   0x0000000000400cdd in main() at test.cpp:16
6       breakpoint     keep y   0x00000000004009e5 in insertionSort(int*, int) 
                                                   at insert.cpp:16
```

#### 删除断点

如果确定设置的某个断点不再被使用了，可用将其删除，删除命令是 delete 断点编号，这个delete可以简写为del也可以再简写为d。删除断点的方式有两种：删除(一个或者多个)指定断点或者删除一个连续的断点区间，具体操作如下：

```shell
# delete == del == d
# 需要 info b 查看断点的信息, 第一列就是编号
(gdb) d 断点的编号1 [断点编号2 ...]
# 举例: 
(gdb) d 1          # 删除第1个断点
(gdb) d 2 4 6      # 删除第2,4,6个断点

# 删除一个范围, 断点编号 num1 - numN 是一个连续区间
(gdb) d num1-numN
# 举例, 删除第1到第5个断点
(gdb) d 1-5
```

#### 设置断点状态

如果某个断点只是临时不需要了，我们可以将其设置为不可用状态, 设置命令为disable 断点编号，当需要的时候再将其设置回可用状态，设置命令为 enable 断点编号。

```shell
# 让断点失效之后, gdb调试过程中程序是不会停在这个位置的
# disable == dis
# 设置某一个或者某几个断点无效
(gdb) dis 断点1的编号 [断点2的编号 ...]

# 设置某个区间断点无效
(gdb) dis 断点1编号-断点n编号
```

```shell
# enable == ena
# 设置某一个或者某几个断点有效
(gdb) ena 断点1的编号 [断点2的编号 ...]

# 设置某个区间断点有效
(gdb) ena 断点1编号-断点n编号
```

### 调试命令

#### 继续运行gdb

如果调试的程序被断点阻塞了又想让程序继续执行，这时候就可以使用continue命令。程序会继续运行, 直到遇到下一个有效的断点。continue可以缩写为 c。

```shell
# continue == c
(gdb) continue
```

#### 手动打印信息

在gdb调试的时候如果需要打印变量的值， 使用的命令是 print，可缩写为 p

```shell
# print == p
(gdb) p 变量名

# 如果变量是一个整形, 默认对应的值是以10进制格式输出, 其他格式请参考上表
(gdb) p/fmt 变量名
```

```shell
# 打印变量类型
(gdb) ptype 变量名
```

#### 单步调试

##### step

step命令可以缩写为s, 命令被执行一次代码被向下执行一行，如果这一行是一个函数调用，那么程序会进入到函数体内部。

```shell
# 从当前代码行位置, 一次调试当前行下的每一行代码
# step == s
# 如果这一行是函数调用, 执行这个命令, 就可以进入到函数体的内部
(gdb) step
```

##### finish

如果通过 s 单步调试进入到函数内部, 想要跳出这个函数体， 可以执行finish命令。如果想要跳出函数体必须要保证函数体内不能有有效断点，否则无法跳出。

```shell
# 如果通过 s 单步调试进入到函数内部, 想要跳出这个函数体
(gdb) finish
```

##### next

next命令和step命令功能是相似的，只是在使用next调试程序的时候不会进入到函数体内部，next可以缩写为 n

```shell
# next == n
# 如果这一行是函数调用, 执行这个命令, 不会进入到函数体的内部
(gdb) next
```

##### until

通过 until 命令可以直接跳出某个循环体，这样就能提高调试效率了。如果想直接从循环体中跳出, 必须要满足以下的条件，否则命令不会生效。

#### 设置变量值

在调试程序的时候, 我们需要在某个变量等于某个特殊值的时候查看程序的运行状态, 但是通过程序运行让变量等于这个值又非常困难, 这种情况下就可以在 gdb 中直接对这个变量进行值的设置, 或者是在单步调试的时候通过设置循环因子的值直接跳出某个循环, 值设置的命令格式为: set var 变量名=值

```shell
# 可以在循环中使用, 直接设置循环因子的值
# 假设某个变量的值在程序中==90的概率是5%, 这时候可以直接通过命令将这个变量值设置为90
(gdb) set var 变量名=值
```

